# Projects API (Serverless + Node.js + DynamoDB Local via Docker)

A minimal CRUD API for a `Project` object:
```json
{
  "id": "uuid",
  "userId": "user-123",
  "name": "My Project",
  "description": "optional"
}
```

## Prereqs
- Node.js 18+ (Node 20 recommended)
- Docker

## Quick Start (Local)
1) Start DynamoDB Local:
```bash
npm run docker:up
```
This launches DynamoDB Local at `http://localhost:8000`.

2) Install deps and start API locally with serverless-offline:
```bash
npm install
npm run dev
```
API base URL will be `http://localhost:3000`.

> Note about versions: this project pins **serverless v4** with **serverless-offline v14** to avoid the common peer dependency error you may have seen when using serverless v3.

3) Create the DynamoDB table (automatically created on real deploy). For local dev with offline, run a no-op deploy once or use AWS CLI. An easy path is to actually `serverless deploy` to AWS (will create the table) and continue developing offline. Alternatively, you can create the table against local DynamoDB using AWS CLI:
```bash
aws dynamodb create-table   --table-name projects-api-dev-Projects   --attribute-definitions AttributeName=id,AttributeType=S AttributeName=userId,AttributeType=S   --key-schema AttributeName=id,KeyType=HASH   --billing-mode PAY_PER_REQUEST   --global-secondary-indexes 'IndexName=UserIndex,KeySchema=[{AttributeName=userId,KeyType=HASH}],Projection={ProjectionType=ALL}'   --endpoint-url http://localhost:8000   --region us-east-1
```
(Replace table name/region if you changed them in `serverless.yml`.)

4) Run the unit tests (Vitest) to verify the handlers:
```bash
npm test
```
Use watch mode while iterating locally:
```bash
npm run test:watch
```

5) (Optional) Run the integration test against DynamoDB Local. Leave the container from step 1 running and execute:
```bash
npm test -- tests/projects.integration.test.ts
```
This test provisions a throwaway table in the local instance, exercises the full CRUD flow, and then cleans everything up.

## Project Structure
- `src/` — Lambda handlers, data access, and shared utilities.
- `tests/` — Vitest suites covering unit and integration scenarios.
- `dist/` — Transpiled JavaScript output generated by `npm run build`.

## Endpoints
- `POST   /projects` — create a project
- `GET    /projects/{id}` — get a project by id
- `GET    /projects` — list projects by userId (via GSI)
- `PUT    /projects/{id}` — update name/description
- `DELETE /projects/{id}` — delete by id

## Example Requests
Create:
```bash
curl -s -X POST http://localhost:3000/projects   -H 'Content-Type: application/json'   -d '{"userId":"u1","name":"alpha","description":"first"}'
```

Get:
```bash
curl -s http://localhost:3000/projects/<id>
```

List by user:
```bash
curl -s http://localhost:3000/projects
```

Update:
```bash
curl -s -X PUT http://localhost:3000/projects/<id>   -H 'Content-Type: application/json'   -d '{"name":"alpha v2","description":"updated"}'
```

Delete:
```bash
curl -i -X DELETE http://localhost:3000/projects/<id>
```

## Deploy to AWS (optional)
```bash
npm run deploy
```
This creates the DynamoDB table and API Gateway/Lambda infrastructure. To tear down:
```bash
npm run remove
```

## Notes
- The code auto-detects `serverless-offline` via `IS_OFFLINE` and points to `http://localhost:8000` for DynamoDB Local.
- For real AWS deploys, no special config is needed—the SDK will use the default AWS credentials/region.
- The table uses PAY_PER_REQUEST billing and includes a `UserIndex` GSI to list projects by `userId`.
- Unit tests use mocked DynamoDB clients for fast iteration; the integration test hits the real local DynamoDB container to validate end-to-end behavior.
